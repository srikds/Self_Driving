# -*- coding: utf-8 -*-
"""
Created on Wed May 19 20:25:26 2021

@author: DUS1BAN
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
plt.close()
img = cv2.imread('bridge_shadow.jpg')
img =cv2.cvtColor(img,cv2.COLOR_BGR2RGB)

#
img_g = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
hls = cv2.cvtColor(img,cv2.COLOR_BGR2HLS)


def abs_sobel_thresh(image, orient, sobel_kernel, thresh):

    sobelx = cv2.Sobel(image,cv2.CV_64F, 0, 1,ksize=sobel_kernel)
    sobely = cv2.Sobel(image,cv2.CV_64F, 1, 0,ksize=sobel_kernel)
    if orient == "x":
        abs_sobel = np.absolute(sobelx)
    elif orient == "y":
        abs_sobel = np.absolute(sobely)
    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))
    grad_binary = np.zeros_like(image)
    grad_binary[(scaled_sobel>=thresh[0]) & (scaled_sobel <= thresh[1])] = 1
    return grad_binary

def mag_thresh(image, sobel_kernel, mag_thresh):
    sobelx = cv2.Sobel(image,cv2.CV_64F, 0, 1,ksize=sobel_kernel)
    sobely = cv2.Sobel(image,cv2.CV_64F, 1, 0,ksize=sobel_kernel)

    sobelxy = np.sqrt(sobelx**2+sobely**2)
    scaled_sobel = np.uint8(255*sobelxy/np.max(sobelxy))
    mag_binary = np.zeros_like(image)
    mag_binary[(scaled_sobel>=mag_thresh[0]) & (scaled_sobel <= mag_thresh[1])] = 1
    return mag_binary

def dir_threshold(image, sobel_kernel, thresh):

    sobelx = cv2.Sobel(image,cv2.CV_64F, 1, 0,ksize=sobel_kernel)
    sobely = cv2.Sobel(image,cv2.CV_64F, 0, 1,ksize=sobel_kernel)
    scaled_sobel = np.arctan2(np.absolute(sobely),np.absolute(sobelx))
    dir_binary = np.zeros_like(image)
    dir_binary[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1    
    return dir_binary

def region_of_interest(img, vertices):
    """
    Applies an image mask.
    """
     
    #defining a blank mask to start with
    mask = np.zeros_like(img)   
    #defining a 3 channel or 1 channel color to fill the mask with depending on the input image
    if len(img.shape) > 2:
        channel_count = img.shape[2]  # i.e. 3 or 4 depending on your image
        ignore_mask_color = (255,) * channel_count
    else:
        ignore_mask_color = 255
    #filling pixels inside the polygon defined by "vertices" with the fill color    
    cv2.fillPoly(mask, vertices, ignore_mask_color)
    
    #returning the image only where mask pixels are nonzero
    masked_image = cv2.bitwise_and(img, mask)
    return masked_image

def draw_lines(img, lines, color=[255, 0, 0], thickness=1):
   
    for line in lines:
        for x1,y1,x2,y2 in line:
            cv2.line(img, (x1, y1), (x2, y2), color, thickness)

def hough_lines(img, rho, theta, threshold, min_line_len, max_line_gap):
    """`img` should be the output of a Canny transform.       
    Returns an image with hough lines drawn.
    """
    lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)
    line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
    draw_lines(line_img, lines)
    return line_img,lines

def weighted_img(img, initial_img, α=0.8, β=1., γ=0.):
    """
    `img` is the output of the hough_lines(), An image with lines drawn on it.
    Should be a blank image (all black) with lines drawn on it.
    
    `initial_img` should be the image before any processing.
    
    The result image is computed as follows:
    
    initial_img * α + img * β + γ
    NOTE: initial_img and img must be the same shape!
    """
    return cv2.addWeighted(initial_img, α, img, β, γ)



#plt.figure(4)
#plt.imshow(combined)
#plt.get_current_fig_manager().window.showMaximized()


#fig = plt.figure(1)
#ax1 = fig.add_subplot(2,2,1)
#ax1.imshow(img)
#ax1.set_title('Original_image')
#ax2 = fig.add_subplot(2,2,2)
#ax2.imshow(h_t)
#ax2.set_title('Hue')
#ax3 = fig.add_subplot(2,2,3)
#ax3.imshow(l_t)
#ax3.set_title('Lightnes')
#ax4 = fig.add_subplot(2,2,4)
#ax4.imshow(s_t)
#ax4.set_title('Saturation')
#plt.get_current_fig_manager().window.showMaximized()
#
#fig = plt.figure(2)
#ax1 = fig.add_subplot(2,2,1)
#ax1.imshow(img)
#ax1.set_title('Original_image')
#ax2 = fig.add_subplot(2,2,2)
#ax2.imshow(r_t)
#ax2.set_title('Red')
#ax3 = fig.add_subplot(2,2,3)
#ax3.imshow(g_t)
#ax3.set_title('Green')
#ax4 = fig.add_subplot(2,2,4)
#ax4.imshow(b_t)
#ax4.set_title('Blue')
#plt.get_current_fig_manager().window.showMaximized()
#
#fig = plt.figure(3)
#ax1 = fig.add_subplot(2,2,1)
#ax1.imshow(img)
#ax1.set_title('Original_image')
#ax2 = fig.add_subplot(2,2,2)
#ax2.imshow(grady)
#ax2.set_title('Gradient Y')
#ax3 = fig.add_subplot(2,2,3)
#ax3.imshow(r_t)
#ax3.set_title('s')
#ax4 = fig.add_subplot(2,2,4)
#ax4.imshow(combined)
#ax4.set_title('Combined S & Gradient Y')
#plt.get_current_fig_manager().window.showMaximized()

r = img[:,:,0]
g = img[:,:,1] 
b = img[:,:,2]

r_t = np.zeros_like(r)
g_t = np.zeros_like(g)
b_t = np.zeros_like(b)

thres = (210,255)

r_t[(r > thres[0]) & (r <= thres[1])] = 1
g_t[(g > thres[0]) & (g <= thres[1])] = 1
b_t[(b > thres[0]) & (b <= thres[1])] = 1

h = hls[:,:,0]
l = hls[:,:,1] 
s = hls[:,:,2]

h_t = np.zeros_like(h)
l_t = np.zeros_like(l)
s_t = np.zeros_like(s)

thres = (15,100)
h_t[(h > thres[0]) & (h <= thres[1])] = 1
thres = (150,255)
l_t[(l > thres[0]) & (l <= thres[1])] = 1
thres = (170,255)
s_t[(s > thres[0]) & (s <= thres[1])] = 1

kernal = 3


rbx=0.1
rtx=.45
lbx=0.9
ltx=.55
rby=1
rty=.6
lby=1
lty=.6
imshape = img_g.shape
vertices = np.array([[(rbx*imshape[1],rby*imshape[0]),(rtx*imshape[1], rty*imshape[0]), (ltx*imshape[1], lty*imshape[0]), (lbx*imshape[1],lby*imshape[0])]], dtype=np.int32)


ksize = 3

gradx = abs_sobel_thresh(img_g, orient='x', sobel_kernel=ksize, thresh=(50, 100))
grady = abs_sobel_thresh(img_g, orient='y', sobel_kernel=ksize, thresh=(20, 100))
mag_binary = mag_thresh(img_g, sobel_kernel=ksize, mag_thresh=(30, 100))

ksize = 15
dir_binary = dir_threshold(img_g, sobel_kernel=ksize, thresh=(0.7, 1.3))

combined = np.zeros_like(img_g)
combined[(grady == 1) | (r_t == 1)] = 1
color_binary = np.dstack(( np.zeros_like(grady), grady, r_t)) * 255

ROI=region_of_interest(combined,vertices)

rho = 0.5 # distance resolution in pixels of the Hough grid
theta = np.pi/180 # angular resolution in radians of the Hough grid
threshold = 10    # minimum number of votes (intersections in Hough grid cell)
min_line_length = 20 #minimum number of pixels making up a line
max_line_gap = 10# maximum gap in pixels between connectable line segments

image_hough,image_lines=hough_lines(ROI,rho,theta,threshold,min_line_length,max_line_gap)


m=[]
b=[]
i=0
for line in image_lines:
    for x1,y1,x2,y2 in line:
        m.append((y2-y1)/(x2-x1))
        b.append(y2-m[i]*x2)
        i=i+1

mp_sum=0
mn_sum=0
bp_sum=0
bn_sum=0
mp_avg=0
mn_avg=0
bp_avg=0
bn_avg=0
p=0
q=0
for i in range(len(m)):
    if m[i]>0.1 and m[i]<2:
        p=p+1
        mp_sum=mp_sum+m[i]
        bp_sum=bp_sum+b[i]
        mp_avg=(mp_sum)/p
        bp_avg=(bp_sum)/p
    elif m[i]<-0.1 and m[i]>-2:
        q=q+1
        mn_sum=mn_sum+m[i]
        bn_sum=bn_sum+b[i]
        mn_avg=mn_sum/q
        bn_avg=bn_sum/q

yu=int(round(rty*imshape[0]))
yb = int(round(rby*imshape[0]))
xlb= int(round((yb-bp_avg)/mp_avg))
xlu=int((yu-bp_avg)/mp_avg)
xrb=int((yb-bn_avg)/mn_avg)
xru= int((yu-bn_avg)/mn_avg)

combined_1=np.dstack((ROI,ROI,ROI))*(255)

cv2.line(combined_1,(xlb,yb),(xlu,yu),color=[255,0,0],thickness=3)
cv2.line(combined_1,(xrb,yb),(xru,yu),color=[255,0,0],thickness=3)    
offset=50
#src = np.float32([(xlb,yb-offset),
#                  (xrb,yb-offset),
#                  (xru,yu),
#                  (xlu,yu)])
x =0.9

src = np.float32([[568, 468], [715, 468], [1040, 680], [270, 680]])
dst = np.float32([[200, 0], [1000, 0], [1000, 680], [200, 680]])

#dst = np.float32([(xlb*x+xlu*(1-x),imshape[0]-offset),
#                  (xrb*x+xru*(1-x),imshape[0]-offset),
#                  (xrb*x+xru*(1-x),0),
#                  (xlb*x+xlu*(1-x),0)])
print(src)
print(dst)
M = cv2.getPerspectiveTransform(src, dst)
pres = cv2.warpPerspective(combined_1,M,(imshape[1],imshape[0]),flags=cv2.INTER_LINEAR)


plt.figure(6)
plt.imshow(pres)
histogram = np.sum(ROI[ROI.shape[0]//2:,:], axis=0)
#plt.figure(7)
#plt.imshow(com_l)
